[Demo](http://shri-dz4-prod.herokuapp.com/)

# Инфраструктура

## Часть 1 - Проверка кода

`npm run lint`
Проверка кода осуществляется при помощи Eslint. Используется конфиг airbnb-base.
Переопределены некоторые правила.

`npm run test`
Тестирование при помощи jest.

## Часть 2 - сборка проекта.

Для сборки выбрал [parcel](https://parceljs.org/) по следующим причинам

* Слышал, что он zero configuration - звучало как то, что мне нужно в условиях столь сжатых сроков (схитрил :))
* Было интересно попробовать этот инструмент

Оказалось, что parcel'ем дейсвительно очень просто собрать проект. Он из коробки безо всяких настроек может собирать js и css (включая препроцессоры, для сборки scss, к примеру достаточно установить node-sass), а так же HMR, опять же без единой строчки конфигурации. Сборщик подхватывает файлы конфигурации postcss и при сборке css прогоняет код через указанные плагины.
Parcel предоставляет middleware для node. Таким образом сборка в данном проекте настраивается всего тремя строчками кода

```
const Bundler = require("parcel-bundler");
const bundler = new Bundler(path.resolve(__dirname, "assets/index.js"));
app.use(bundler.middleware());
```

Если проект запускается в production окружении, бандлер минифицирует код.

Чтобы посмотреть как это работает нужно запустить проект командой `npm run dev`
При изменениях в js и scss файлах в директории `assets/` будет выполяться пересборка с логированием в консоль.

Минусы сборщика - слабоватая документация, на сложных проектах наверняка начнет нехватать возможности гибкой конфигурациц, но это не точно.

## Часть 3 - контейнеризация

EXPOSE, на сколько я понял ингорируется heroku, оставил в конфиге для работы с контейнером на локальной машине.

## Часть 4 - CI + CD

github + travis + heroku

Получилась следующая схема.
После того как пушим на github из любой ветки, travis подхватывает этот камит, и начинает проверку (запускает линтер, прогоняет тесты). Для этого на travis билдится docker контейнер (в соответствии с конфигом в нашем Dockerfile), запускается, и в нем уже прогоняются тесты. Кто-то из ребят говорил, что такое не требуется и можно гонять тесты в окружении, которое предоставляет travis (language: node_js в конфиге). Я руководствовался следующей логикой - коли мы используем контейнер, чтобы избавиться от в нешних зависимостей и чтобы приложение всегда работало в "родном" окружении, то и тесты следует гонять в нем же. Возмножно это неверная логика, в таком случае ок, я могу сконфигурировать travis и по другому.

После того как проверка успешно завершилась возможны следующие сценарии

* Мы пушили в ветку отличную от master
  Travis скипает деплой и завершает работу
* Мы пул-реквестим некоторую ветку в master на гитхабе
  На хероку из docker контейнера деплоится review app (shri-dz4-staging-pr). После подтверждения пулреквеста и мерджа на гитхабе на heroku из docker контейнера деплоится наше приложение в staging режиме
* Мы пушили в мастер без тэга
  На heroku из docker контейнера деплоится наше приложение в staging режиме
* Мы пушм в мастре с тэгом
  на heroku из docker контейнера деплоится наше приложение в production режиме

# NODE.JS Приложение

~~_На данный момент приложение выложено "как есть". Требуемый функционал полностью реализован. При этом не проведен достаточный рефакторинг, не задокументирован код. Расчитываю успеть исправить до проверки._~~

Для запуска
`npm run star`
Приложение будет доступно на `http://localhost:3000`

Приложение позволяет выбрать для работы один из репозиториев, лежащих в специальной директории (директория указывается в переменной окружения `REPOS_DIR`, хранится в `.env` файле, подгружается при помощи модуля `dotenv`). Сделано с целью в последствии добавить возможность склонировать в данную директорию произвольный репозиторий.

Для получения необходимых данных о репозитории используются следующие команды git:

* `git branch -v` - для получения списка репозиториев
* `git log ${hash} --format=...` - для получения списка камитов
* `git ls-tree` для извлечения данных о файловой системе
* `git cat-file ${hash}` для получения содержимого файла.

Все команды запускаются с помощью промисифицированного (мной) node child_process.exe.

Для реализации хлебных крошек использю довольно наивный алгоритм: получаю файлы для текущего tree object, затем (парся `git ls-tree -r`) строю дерево фс для всего репозитория, при помощи которого вычисляю дерево родителей для файлов потомков текущего tree object. Можно было хранить путь до текущего уровня вложенности в url. Работало бы быстрее, но мы бы уперлись в длину урла и максимальную возможную вложеность.
